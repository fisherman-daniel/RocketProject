'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: protocol.xml

Note: this file has been auto-generated. DO NOT EDIT
'''
from __future__ import print_function
from builtins import range
from builtins import object
import struct, array, time, json, os, sys, platform

from pymavlink.generator.mavcrc import x25crc
import hashlib

WIRE_PROTOCOL_VERSION = '1.0'
DIALECT = 'mavlink'

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

native_supported = platform.system() != 'Windows' # Not yet supported on other dialects
native_force = 'MAVNATIVE_FORCE' in os.environ # Will force use of native code regardless of what client app wants
native_testing = 'MAVNATIVE_TESTING' in os.environ # Will force both native and legacy code to be used and their results compared

if native_supported and float(WIRE_PROTOCOL_VERSION) <= 1:
    try:
        import mavnative
    except ImportError:
        print('ERROR LOADING MAVNATIVE - falling back to python implementation')
        native_supported = False
else:
    # mavnative isn't supported for MAVLink2 yet
    native_supported = False

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, incompat_flags=0, compat_flags=0, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1=False):
        if WIRE_PROTOCOL_VERSION == '2.0' and not force_mavlink1:
            return struct.pack('<BBBBBBBHB', 254, self.mlen,
                               self.incompat_flags, self.compat_flags,
                               self.seq, self.srcSystem, self.srcComponent,
                               self.msgId&0xFFFF, self.msgId>>16)
        return struct.pack('<BBBBBB', PROTOCOL_MARKER_V1, self.mlen, self.seq,
                           self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name
        self._signed     = False
        self._link_id    = None
        self._instances  = None
        self._instance_field = None

    # swiped from DFReader.py
    def to_string(self, s):
        '''desperate attempt to convert a string regardless of what garbage we get'''
        try:
            return s.decode("utf-8")
        except Exception as e:
            pass
        try:
            s2 = s.encode('utf-8', 'ignore')
            x = u"%s" % s2
            return s2
        except Exception:
            pass
        # so its a nasty one. Let's grab as many characters as we can
        r = ''
        while s != '':
            try:
                r2 = r + s[0]
                s = s[1:]
                r2 = r2.encode('ascii', 'ignore')
                x = u"%s" % r2
                r = r2
            except Exception:
                break
        return r + '_XXX'

    def format_attr(self, field):
        '''override field getter'''
        raw_attr = getattr(self,field)
        if isinstance(raw_attr, bytes):
            raw_attr = self.to_string(raw_attr).rstrip("\00")
        return raw_attr

    def get_msgbuf(self):
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def get_signed(self):
        return self._signed

    def get_link_id(self):
        return self._link_id

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = self.format_attr(a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other is None:
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        #if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = self.format_attr(a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def sign_packet(self, mav):
        h = hashlib.new('sha256')
        self._msgbuf += struct.pack('<BQ', mav.signing.link_id, mav.signing.timestamp)[:7]
        h.update(mav.signing.secret_key)
        h.update(self._msgbuf)
        sig = h.digest()[:6]
        self._msgbuf += sig
        mav.signing.timestamp += 1

    def pack(self, mav, crc_extra, payload, force_mavlink1=False):
        plen = len(payload)
        if WIRE_PROTOCOL_VERSION != '1.0' and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            nullbyte = chr(0)
            # in Python2, type("fred') is str but also type("fred")==bytes
            if str(type(payload)) == "<class 'bytes'>":
                nullbyte = 0
            while plen > 1 and payload[plen-1] == nullbyte:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        if mav.signing.sign_outgoing:
            incompat_flags |= MAVLINK_IFLAG_SIGNED
        self._header  = MAVLink_header(self._header.msgId,
                                       incompat_flags=incompat_flags, compat_flags=0,
                                       mlen=len(self._payload), seq=mav.seq,
                                       srcSystem=mav.srcSystem, srcComponent=mav.srcComponent)
        self._msgbuf = self._header.pack(force_mavlink1=force_mavlink1) + self._payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate_str(struct.pack('B', crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        if mav.signing.sign_outgoing and not force_mavlink1:
            self.sign_packet(mav)
        return self._msgbuf

    def __getitem__(self, key):
        '''support indexing, allowing for multi-instance sensors in one message'''
        if self._instances is None:
            raise IndexError()
        if not key in self._instances:
            raise IndexError()
        return self._instances[key]


# enums

class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}

enums = {}

# SYSTEM_TYPE
enums['SYSTEM_TYPE'] = {}
GROUND_STATION = 1 # 
enums['SYSTEM_TYPE'][1] = EnumEntry('GROUND_STATION', '''''')
ROCKET = 2 # 
enums['SYSTEM_TYPE'][2] = EnumEntry('ROCKET', '''''')
SYSTEM_TYPE_ENUM_END = 3 # 
enums['SYSTEM_TYPE'][3] = EnumEntry('SYSTEM_TYPE_ENUM_END', '''''')

# COMPONENT_TYPE
enums['COMPONENT_TYPE'] = {}
ENGINE_COMPUTER = 1 # 
enums['COMPONENT_TYPE'][1] = EnumEntry('ENGINE_COMPUTER', '''''')
FLIGHT_COMPUTER = 2 # 
enums['COMPONENT_TYPE'][2] = EnumEntry('FLIGHT_COMPUTER', '''''')
RADIO_COMPUTER = 3 # 
enums['COMPONENT_TYPE'][3] = EnumEntry('RADIO_COMPUTER', '''''')
COMPONENT_TYPE_ENUM_END = 4 # 
enums['COMPONENT_TYPE'][4] = EnumEntry('COMPONENT_TYPE_ENUM_END', '''''')

# COMPONENT_STATUS
enums['COMPONENT_STATUS'] = {}
READY = 1 # 
enums['COMPONENT_STATUS'][1] = EnumEntry('READY', '''''')
ARMED = 2 # 
enums['COMPONENT_STATUS'][2] = EnumEntry('ARMED', '''''')
LOW_POWER = 3 # 
enums['COMPONENT_STATUS'][3] = EnumEntry('LOW_POWER', '''''')
COMPONENT_STATUS_ENUM_END = 4 # 
enums['COMPONENT_STATUS'][4] = EnumEntry('COMPONENT_STATUS_ENUM_END', '''''')

# ARM_STATE
enums['ARM_STATE'] = {}
ARM = 1 # 
enums['ARM_STATE'][1] = EnumEntry('ARM', '''''')
SAFE = 2 # 
enums['ARM_STATE'][2] = EnumEntry('SAFE', '''''')
ARM_STATE_ENUM_END = 3 # 
enums['ARM_STATE'][3] = EnumEntry('ARM_STATE_ENUM_END', '''''')

# ACK_RESULT
enums['ACK_RESULT'] = {}
COMPLETE = 1 # 
enums['ACK_RESULT'][1] = EnumEntry('COMPLETE', '''''')
FAILED = 2 # 
enums['ACK_RESULT'][2] = EnumEntry('FAILED', '''''')
IN_PROGRESS = 3 # 
enums['ACK_RESULT'][3] = EnumEntry('IN_PROGRESS', '''''')
ACK_RESULT_ENUM_END = 4 # 
enums['ACK_RESULT'][4] = EnumEntry('ACK_RESULT_ENUM_END', '''''')

# VALVE
enums['VALVE'] = {}
FUEL_MAIN = 1 # 
enums['VALVE'][1] = EnumEntry('FUEL_MAIN', '''''')
OX_MAIN = 2 # 
enums['VALVE'][2] = EnumEntry('OX_MAIN', '''''')
FUEL_VENT = 3 # 
enums['VALVE'][3] = EnumEntry('FUEL_VENT', '''''')
OX_VENT = 4 # 
enums['VALVE'][4] = EnumEntry('OX_VENT', '''''')
VALVE_ENUM_END = 5 # 
enums['VALVE'][5] = EnumEntry('VALVE_ENUM_END', '''''')

# VALVE_MODE
enums['VALVE_MODE'] = {}
POSITION_CONTROL = 1 # 
enums['VALVE_MODE'][1] = EnumEntry('POSITION_CONTROL', '''''')
PULSE = 2 # 
enums['VALVE_MODE'][2] = EnumEntry('PULSE', '''''')
HOME_ENCODER = 3 # 
enums['VALVE_MODE'][3] = EnumEntry('HOME_ENCODER', '''''')
AUTO_POSITION_CONTROL = 4 # 
enums['VALVE_MODE'][4] = EnumEntry('AUTO_POSITION_CONTROL', '''''')
VALVE_MODE_ENUM_END = 5 # 
enums['VALVE_MODE'][5] = EnumEntry('VALVE_MODE_ENUM_END', '''''')

# IGNITOR_STATE_FLAGS
enums['IGNITOR_STATE_FLAGS'] = {}
CONTINUITY_GOOD = 1 # 
enums['IGNITOR_STATE_FLAGS'][1] = EnumEntry('CONTINUITY_GOOD', '''''')
FIRING = 2 # 
enums['IGNITOR_STATE_FLAGS'][2] = EnumEntry('FIRING', '''''')
IGNITOR_STATE_FLAGS_ENUM_END = 3 # 
enums['IGNITOR_STATE_FLAGS'][3] = EnumEntry('IGNITOR_STATE_FLAGS_ENUM_END', '''''')

# TANK_FLAGS
enums['TANK_FLAGS'] = {}
FUEL = 1 # 
enums['TANK_FLAGS'][1] = EnumEntry('FUEL', '''''')
OX = 2 # 
enums['TANK_FLAGS'][2] = EnumEntry('OX', '''''')
TANK_FLAGS_ENUM_END = 3 # 
enums['TANK_FLAGS'][3] = EnumEntry('TANK_FLAGS_ENUM_END', '''''')

# PRESSURE_STATUS
enums['PRESSURE_STATUS'] = {}
SAFE = 1 # 
enums['PRESSURE_STATUS'][1] = EnumEntry('SAFE', '''''')
WARN = 2 # 
enums['PRESSURE_STATUS'][2] = EnumEntry('WARN', '''''')
ABORT = 3 # 
enums['PRESSURE_STATUS'][3] = EnumEntry('ABORT', '''''')
PRESSURE_STATUS_ENUM_END = 4 # 
enums['PRESSURE_STATUS'][4] = EnumEntry('PRESSURE_STATUS_ENUM_END', '''''')

# POWER_SOURCE
enums['POWER_SOURCE'] = {}
BATTERY = 1 # 
enums['POWER_SOURCE'][1] = EnumEntry('BATTERY', '''''')
EXTERNAL = 2 # 
enums['POWER_SOURCE'][2] = EnumEntry('EXTERNAL', '''''')
POWER_SOURCE_ENUM_END = 3 # 
enums['POWER_SOURCE'][3] = EnumEntry('POWER_SOURCE_ENUM_END', '''''')

# ENGINE_COMPUTER_STATE
enums['ENGINE_COMPUTER_STATE'] = {}
PREFLIGHT_CHECK = 1 # 
enums['ENGINE_COMPUTER_STATE'][1] = EnumEntry('PREFLIGHT_CHECK', '''''')
FUEL_PRESS = 2 # 
enums['ENGINE_COMPUTER_STATE'][2] = EnumEntry('FUEL_PRESS', '''''')
OX_PRESS = 3 # 
enums['ENGINE_COMPUTER_STATE'][3] = EnumEntry('OX_PRESS', '''''')
PREBURN_CHECK = 4 # 
enums['ENGINE_COMPUTER_STATE'][4] = EnumEntry('PREBURN_CHECK', '''''')
IGNITION_AUTOSEQ = 5 # 
enums['ENGINE_COMPUTER_STATE'][5] = EnumEntry('IGNITION_AUTOSEQ', '''''')
BURN_AUTOSEQ = 6 # 
enums['ENGINE_COMPUTER_STATE'][6] = EnumEntry('BURN_AUTOSEQ', '''''')
ENGINE_CUTOFF = 7 # 
enums['ENGINE_COMPUTER_STATE'][7] = EnumEntry('ENGINE_CUTOFF', '''''')
POSTBURN_VENT = 8 # 
enums['ENGINE_COMPUTER_STATE'][8] = EnumEntry('POSTBURN_VENT', '''''')
COMPLETE = 9 # 
enums['ENGINE_COMPUTER_STATE'][9] = EnumEntry('COMPLETE', '''''')
ABORT_GENERIC = 10 # 
enums['ENGINE_COMPUTER_STATE'][10] = EnumEntry('ABORT_GENERIC', '''''')
ABORT_DURING_IGNITION_AUTOSEQ = 11 # 
enums['ENGINE_COMPUTER_STATE'][11] = EnumEntry('ABORT_DURING_IGNITION_AUTOSEQ', '''''')
HARD_ABORT_DURING_BURN_AUTOSEQ = 12 # 
enums['ENGINE_COMPUTER_STATE'][12] = EnumEntry('HARD_ABORT_DURING_BURN_AUTOSEQ', '''''')
SOFT_ABORT_DURING_BURN_AUTOSEQ = 13 # 
enums['ENGINE_COMPUTER_STATE'][13] = EnumEntry('SOFT_ABORT_DURING_BURN_AUTOSEQ', '''''')
ENGINE_COMPUTER_STATE_ENUM_END = 14 # 
enums['ENGINE_COMPUTER_STATE'][14] = EnumEntry('ENGINE_COMPUTER_STATE_ENUM_END', '''''')

# ABORT_CONDITION
enums['ABORT_CONDITION'] = {}
MANUAL_ABORT = 1 # 
enums['ABORT_CONDITION'][1] = EnumEntry('MANUAL_ABORT', '''''')
FUEL_TANK_OVERPRESS = 2 # 
enums['ABORT_CONDITION'][2] = EnumEntry('FUEL_TANK_OVERPRESS', '''''')
OX_TANK_OVERPRESS = 4 # 
enums['ABORT_CONDITION'][4] = EnumEntry('OX_TANK_OVERPRESS', '''''')
FUEL_INJ_OVERPRESS = 8 # 
enums['ABORT_CONDITION'][8] = EnumEntry('FUEL_INJ_OVERPRESS', '''''')
OX_INJ_OVERPRESS = 16 # 
enums['ABORT_CONDITION'][16] = EnumEntry('OX_INJ_OVERPRESS', '''''')
IGNITION_TIMEOUT = 32 # 
enums['ABORT_CONDITION'][32] = EnumEntry('IGNITION_TIMEOUT', '''''')
LINK_TIMEOUT = 64 # 
enums['ABORT_CONDITION'][64] = EnumEntry('LINK_TIMEOUT', '''''')
ABORT_CONDITION_ENUM_END = 65 # 
enums['ABORT_CONDITION'][65] = EnumEntry('ABORT_CONDITION_ENUM_END', '''''')

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_HEARTBEAT = 0
MAVLINK_MSG_ID_PREP_CMD = 1
MAVLINK_MSG_ID_ACK_CMD = 2
MAVLINK_MSG_ID_CMD_REQUEST_MESSAGE = 3
MAVLINK_MSG_ID_CMD_SET_MESSAGE_INTERVAL = 4
MAVLINK_MSG_ID_ENGINE_SENSORS = 32
MAVLINK_MSG_ID_TANK_SENSORS = 33
MAVLINK_MSG_ID_POWER_SENSOR = 34
MAVLINK_MSG_ID_ENGINE_COMPUTER_STATUS = 35
MAVLINK_MSG_ID_CMD_ABORT = 64
MAVLINK_MSG_ID_CMD_GOTO_STATE = 65
MAVLINK_MSG_ID_CMD_PROCEED = 66
MAVLINK_MSG_ID_CMD_SET_VALVE = 96
MAVLINK_MSG_ID_CMD_SET_POWER_SOURCE = 97
MAVLINK_MSG_ID_SET_ARM_STATE = 98

class MAVLink_heartbeat_message(MAVLink_message):
        '''

        '''
        id = MAVLINK_MSG_ID_HEARTBEAT
        name = 'HEARTBEAT'
        fieldnames = ['system_type', 'component_type']
        ordered_fieldnames = ['system_type', 'component_type']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 86
        unpacker = struct.Struct('<BB')
        instance_field = None
        instance_offset = -1

        def __init__(self, system_type, component_type):
                MAVLink_message.__init__(self, MAVLink_heartbeat_message.id, MAVLink_heartbeat_message.name)
                self._fieldnames = MAVLink_heartbeat_message.fieldnames
                self._instance_field = MAVLink_heartbeat_message.instance_field
                self._instance_offset = MAVLink_heartbeat_message.instance_offset
                self.system_type = system_type
                self.component_type = component_type

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 86, struct.pack('<BB', self.system_type, self.component_type), force_mavlink1=force_mavlink1)

class MAVLink_prep_cmd_message(MAVLink_message):
        '''
        Send before an important command which needs acknowledgement.
        Only relevant systems/components should take action. Commands
        are ignored if this is not received.
        '''
        id = MAVLINK_MSG_ID_PREP_CMD
        name = 'PREP_CMD'
        fieldnames = ['target_system', 'target_component', 'message_id']
        ordered_fieldnames = ['target_system', 'target_component', 'message_id']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 122
        unpacker = struct.Struct('<BBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, message_id):
                MAVLink_message.__init__(self, MAVLink_prep_cmd_message.id, MAVLink_prep_cmd_message.name)
                self._fieldnames = MAVLink_prep_cmd_message.fieldnames
                self._instance_field = MAVLink_prep_cmd_message.instance_field
                self._instance_offset = MAVLink_prep_cmd_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.message_id = message_id

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 122, struct.pack('<BBB', self.target_system, self.target_component, self.message_id), force_mavlink1=force_mavlink1)

class MAVLink_ack_cmd_message(MAVLink_message):
        '''
        Acknowledges that a command was received and successfully
        executed.
        '''
        id = MAVLINK_MSG_ID_ACK_CMD
        name = 'ACK_CMD'
        fieldnames = ['message_id', 'result']
        ordered_fieldnames = ['message_id', 'result']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"result": "ACK_RESULT"}
        fieldunits_by_name = {}
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 82
        unpacker = struct.Struct('<BB')
        instance_field = None
        instance_offset = -1

        def __init__(self, message_id, result):
                MAVLink_message.__init__(self, MAVLink_ack_cmd_message.id, MAVLink_ack_cmd_message.name)
                self._fieldnames = MAVLink_ack_cmd_message.fieldnames
                self._instance_field = MAVLink_ack_cmd_message.instance_field
                self._instance_offset = MAVLink_ack_cmd_message.instance_offset
                self.message_id = message_id
                self.result = result

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 82, struct.pack('<BB', self.message_id, self.result), force_mavlink1=force_mavlink1)

class MAVLink_cmd_request_message_message(MAVLink_message):
        '''
        Asks for one-time transmission of a certain message
        '''
        id = MAVLINK_MSG_ID_CMD_REQUEST_MESSAGE
        name = 'CMD_REQUEST_MESSAGE'
        fieldnames = ['message_id']
        ordered_fieldnames = ['message_id']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 195
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, message_id):
                MAVLink_message.__init__(self, MAVLink_cmd_request_message_message.id, MAVLink_cmd_request_message_message.name)
                self._fieldnames = MAVLink_cmd_request_message_message.fieldnames
                self._instance_field = MAVLink_cmd_request_message_message.instance_field
                self._instance_offset = MAVLink_cmd_request_message_message.instance_offset
                self.message_id = message_id

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 195, struct.pack('<B', self.message_id), force_mavlink1=force_mavlink1)

class MAVLink_cmd_set_message_interval_message(MAVLink_message):
        '''
        Asks for repeat transmission of a certain message
        '''
        id = MAVLINK_MSG_ID_CMD_SET_MESSAGE_INTERVAL
        name = 'CMD_SET_MESSAGE_INTERVAL'
        fieldnames = ['message_id', 'interval']
        ordered_fieldnames = ['interval', 'message_id']
        fieldtypes = ['uint8_t', 'uint16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"interval": "ms"}
        format = '<HB'
        native_format = bytearray('<HB', 'ascii')
        orders = [1, 0]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 201
        unpacker = struct.Struct('<HB')
        instance_field = None
        instance_offset = -1

        def __init__(self, message_id, interval):
                MAVLink_message.__init__(self, MAVLink_cmd_set_message_interval_message.id, MAVLink_cmd_set_message_interval_message.name)
                self._fieldnames = MAVLink_cmd_set_message_interval_message.fieldnames
                self._instance_field = MAVLink_cmd_set_message_interval_message.instance_field
                self._instance_offset = MAVLink_cmd_set_message_interval_message.instance_offset
                self.message_id = message_id
                self.interval = interval

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 201, struct.pack('<HB', self.interval, self.message_id), force_mavlink1=force_mavlink1)

class MAVLink_engine_sensors_message(MAVLink_message):
        '''
        All engine sensor info
        '''
        id = MAVLINK_MSG_ID_ENGINE_SENSORS
        name = 'ENGINE_SENSORS'
        fieldnames = ['fuel_main_valve_mode', 'fuel_main_valve_position', 'fuel_main_valve_desired_position', 'fuel_main_valve_motor_power', 'ox_main_valve_mode', 'ox_main_valve_position', 'ox_main_valve_desired_position', 'ox_main_valve_motor_power', 'fuel_injector_pressure', 'fuel_injector_pressure_status', 'ox_injector_pressure', 'ox_injector_pressure_status', 'thrust', 'ignitor_status']
        ordered_fieldnames = ['fuel_injector_pressure', 'ox_injector_pressure', 'thrust', 'fuel_main_valve_mode', 'fuel_main_valve_position', 'fuel_main_valve_desired_position', 'fuel_main_valve_motor_power', 'ox_main_valve_mode', 'ox_main_valve_position', 'ox_main_valve_desired_position', 'ox_main_valve_motor_power', 'fuel_injector_pressure_status', 'ox_injector_pressure_status', 'ignitor_status']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'float', 'uint8_t', 'float', 'uint8_t', 'float', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"fuel_main_valve_mode": "VALVE_MODE", "ox_main_valve_mode": "VALVE_MODE", "fuel_injector_pressure_status": "PRESSURE_STATUS", "ox_injector_pressure_status": "PRESSURE_STATUS", "ignitor_status": "IGNITOR_STATUS"}
        fieldunits_by_name = {"fuel_main_valve_position": "%open", "fuel_main_valve_desired_position": "%open", "ox_main_valve_position": "%open", "ox_main_valve_desired_position": "%open", "fuel_injector_pressure": "bar", "ox_injector_pressure": "bar", "thrust": "N"}
        format = '<fffBBBBBBBBBBB'
        native_format = bytearray('<fffBBBBBBBBBBB', 'ascii')
        orders = [3, 4, 5, 6, 7, 8, 9, 10, 0, 11, 1, 12, 2, 13]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 6
        unpacker = struct.Struct('<fffBBBBBBBBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, fuel_main_valve_mode, fuel_main_valve_position, fuel_main_valve_desired_position, fuel_main_valve_motor_power, ox_main_valve_mode, ox_main_valve_position, ox_main_valve_desired_position, ox_main_valve_motor_power, fuel_injector_pressure, fuel_injector_pressure_status, ox_injector_pressure, ox_injector_pressure_status, thrust, ignitor_status):
                MAVLink_message.__init__(self, MAVLink_engine_sensors_message.id, MAVLink_engine_sensors_message.name)
                self._fieldnames = MAVLink_engine_sensors_message.fieldnames
                self._instance_field = MAVLink_engine_sensors_message.instance_field
                self._instance_offset = MAVLink_engine_sensors_message.instance_offset
                self.fuel_main_valve_mode = fuel_main_valve_mode
                self.fuel_main_valve_position = fuel_main_valve_position
                self.fuel_main_valve_desired_position = fuel_main_valve_desired_position
                self.fuel_main_valve_motor_power = fuel_main_valve_motor_power
                self.ox_main_valve_mode = ox_main_valve_mode
                self.ox_main_valve_position = ox_main_valve_position
                self.ox_main_valve_desired_position = ox_main_valve_desired_position
                self.ox_main_valve_motor_power = ox_main_valve_motor_power
                self.fuel_injector_pressure = fuel_injector_pressure
                self.fuel_injector_pressure_status = fuel_injector_pressure_status
                self.ox_injector_pressure = ox_injector_pressure
                self.ox_injector_pressure_status = ox_injector_pressure_status
                self.thrust = thrust
                self.ignitor_status = ignitor_status

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 6, struct.pack('<fffBBBBBBBBBBB', self.fuel_injector_pressure, self.ox_injector_pressure, self.thrust, self.fuel_main_valve_mode, self.fuel_main_valve_position, self.fuel_main_valve_desired_position, self.fuel_main_valve_motor_power, self.ox_main_valve_mode, self.ox_main_valve_position, self.ox_main_valve_desired_position, self.ox_main_valve_motor_power, self.fuel_injector_pressure_status, self.ox_injector_pressure_status, self.ignitor_status), force_mavlink1=force_mavlink1)

class MAVLink_tank_sensors_message(MAVLink_message):
        '''
        All tank sensor info
        '''
        id = MAVLINK_MSG_ID_TANK_SENSORS
        name = 'TANK_SENSORS'
        fieldnames = ['fuel_vent_valve_mode', 'fuel_vent_valve_position', 'fuel_vent_valve_desired_position', 'fuel_vent_valve_motor_power', 'ox_vent_valve_mode', 'ox_vent_valve_position', 'ox_vent_valve_desired_position', 'ox_vent_valve_motor_power', 'fuel_tank_pressure', 'fuel_tank_pressure_status', 'ox_tank_pressure', 'ox_tank_pressure_status', 'fuel_tank_fill_level', 'ox_tank_fill_level', 'fill_lines_detected']
        ordered_fieldnames = ['fuel_tank_pressure', 'ox_tank_pressure', 'fuel_vent_valve_mode', 'fuel_vent_valve_position', 'fuel_vent_valve_desired_position', 'fuel_vent_valve_motor_power', 'ox_vent_valve_mode', 'ox_vent_valve_position', 'ox_vent_valve_desired_position', 'ox_vent_valve_motor_power', 'fuel_tank_pressure_status', 'ox_tank_pressure_status', 'fuel_tank_fill_level', 'ox_tank_fill_level', 'fill_lines_detected']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'float', 'uint8_t', 'float', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"fuel_vent_valve_mode": "VALVE_MODE", "ox_vent_valve_mode": "VALVE_MODE", "fuel_tank_pressure_status": "PRESSURE_STATUS", "ox_tank_pressure_status": "PRESSURE_STATUS", "fill_lines_detected": "TANK_FLAGS"}
        fieldunits_by_name = {"fuel_vent_valve_position": "%open", "fuel_vent_valve_desired_position": "%open", "ox_vent_valve_position": "%open", "ox_vent_valve_desired_position": "%open", "fuel_tank_pressure": "bar", "ox_tank_pressure": "bar", "fuel_tank_fill_level": "%", "ox_tank_fill_level": "%"}
        format = '<ffBBBBBBBBBBBBB'
        native_format = bytearray('<ffBBBBBBBBBBBBB', 'ascii')
        orders = [2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 1, 11, 12, 13, 14]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 133
        unpacker = struct.Struct('<ffBBBBBBBBBBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, fuel_vent_valve_mode, fuel_vent_valve_position, fuel_vent_valve_desired_position, fuel_vent_valve_motor_power, ox_vent_valve_mode, ox_vent_valve_position, ox_vent_valve_desired_position, ox_vent_valve_motor_power, fuel_tank_pressure, fuel_tank_pressure_status, ox_tank_pressure, ox_tank_pressure_status, fuel_tank_fill_level, ox_tank_fill_level, fill_lines_detected):
                MAVLink_message.__init__(self, MAVLink_tank_sensors_message.id, MAVLink_tank_sensors_message.name)
                self._fieldnames = MAVLink_tank_sensors_message.fieldnames
                self._instance_field = MAVLink_tank_sensors_message.instance_field
                self._instance_offset = MAVLink_tank_sensors_message.instance_offset
                self.fuel_vent_valve_mode = fuel_vent_valve_mode
                self.fuel_vent_valve_position = fuel_vent_valve_position
                self.fuel_vent_valve_desired_position = fuel_vent_valve_desired_position
                self.fuel_vent_valve_motor_power = fuel_vent_valve_motor_power
                self.ox_vent_valve_mode = ox_vent_valve_mode
                self.ox_vent_valve_position = ox_vent_valve_position
                self.ox_vent_valve_desired_position = ox_vent_valve_desired_position
                self.ox_vent_valve_motor_power = ox_vent_valve_motor_power
                self.fuel_tank_pressure = fuel_tank_pressure
                self.fuel_tank_pressure_status = fuel_tank_pressure_status
                self.ox_tank_pressure = ox_tank_pressure
                self.ox_tank_pressure_status = ox_tank_pressure_status
                self.fuel_tank_fill_level = fuel_tank_fill_level
                self.ox_tank_fill_level = ox_tank_fill_level
                self.fill_lines_detected = fill_lines_detected

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 133, struct.pack('<ffBBBBBBBBBBBBB', self.fuel_tank_pressure, self.ox_tank_pressure, self.fuel_vent_valve_mode, self.fuel_vent_valve_position, self.fuel_vent_valve_desired_position, self.fuel_vent_valve_motor_power, self.ox_vent_valve_mode, self.ox_vent_valve_position, self.ox_vent_valve_desired_position, self.ox_vent_valve_motor_power, self.fuel_tank_pressure_status, self.ox_tank_pressure_status, self.fuel_tank_fill_level, self.ox_tank_fill_level, self.fill_lines_detected), force_mavlink1=force_mavlink1)

class MAVLink_power_sensor_message(MAVLink_message):
        '''
        Info about power supply
        '''
        id = MAVLINK_MSG_ID_POWER_SENSOR
        name = 'POWER_SENSOR'
        fieldnames = ['power_source', 'battery_voltage', 'battery_status']
        ordered_fieldnames = ['battery_voltage', 'power_source', 'battery_status']
        fieldtypes = ['uint8_t', 'uint16_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"power_source": "POWER_SOURCE", "battery_status": "BATTERY_STATUS"}
        fieldunits_by_name = {"battery_voltage": "mV"}
        format = '<HBB'
        native_format = bytearray('<HBB', 'ascii')
        orders = [1, 0, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 208
        unpacker = struct.Struct('<HBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, power_source, battery_voltage, battery_status):
                MAVLink_message.__init__(self, MAVLink_power_sensor_message.id, MAVLink_power_sensor_message.name)
                self._fieldnames = MAVLink_power_sensor_message.fieldnames
                self._instance_field = MAVLink_power_sensor_message.instance_field
                self._instance_offset = MAVLink_power_sensor_message.instance_offset
                self.power_source = power_source
                self.battery_voltage = battery_voltage
                self.battery_status = battery_status

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 208, struct.pack('<HBB', self.battery_voltage, self.power_source, self.battery_status), force_mavlink1=force_mavlink1)

class MAVLink_engine_computer_status_message(MAVLink_message):
        '''
        Info about state machine, arming, abort-worthy issues
        '''
        id = MAVLINK_MSG_ID_ENGINE_COMPUTER_STATUS
        name = 'ENGINE_COMPUTER_STATUS'
        fieldnames = ['state', 'state_proceed', 'state_abort', 'abort_flags', 'arm_state', 'cpu_load']
        ordered_fieldnames = ['abort_flags', 'state', 'state_proceed', 'state_abort', 'arm_state', 'cpu_load']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint16_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"state": "ENGINE_COMPUTER_STATE", "state_proceed": "ENGINE_COMPUTER_STATE", "state_abort": "ENGINE_COMPUTER_STATE", "abort_flags": "ABORT_CONDITION_FLAGS", "arm_state": "ARM_STATE"}
        fieldunits_by_name = {"cpu_load": "%"}
        format = '<HBBBBB'
        native_format = bytearray('<HBBBBB', 'ascii')
        orders = [1, 2, 3, 0, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 165
        unpacker = struct.Struct('<HBBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, state, state_proceed, state_abort, abort_flags, arm_state, cpu_load):
                MAVLink_message.__init__(self, MAVLink_engine_computer_status_message.id, MAVLink_engine_computer_status_message.name)
                self._fieldnames = MAVLink_engine_computer_status_message.fieldnames
                self._instance_field = MAVLink_engine_computer_status_message.instance_field
                self._instance_offset = MAVLink_engine_computer_status_message.instance_offset
                self.state = state
                self.state_proceed = state_proceed
                self.state_abort = state_abort
                self.abort_flags = abort_flags
                self.arm_state = arm_state
                self.cpu_load = cpu_load

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 165, struct.pack('<HBBBBB', self.abort_flags, self.state, self.state_proceed, self.state_abort, self.arm_state, self.cpu_load), force_mavlink1=force_mavlink1)

class MAVLink_cmd_abort_message(MAVLink_message):
        '''

        '''
        id = MAVLINK_MSG_ID_CMD_ABORT
        name = 'CMD_ABORT'
        fieldnames = ['hard']
        ordered_fieldnames = ['hard']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 21
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, hard):
                MAVLink_message.__init__(self, MAVLink_cmd_abort_message.id, MAVLink_cmd_abort_message.name)
                self._fieldnames = MAVLink_cmd_abort_message.fieldnames
                self._instance_field = MAVLink_cmd_abort_message.instance_field
                self._instance_offset = MAVLink_cmd_abort_message.instance_offset
                self.hard = hard

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 21, struct.pack('<B', self.hard), force_mavlink1=force_mavlink1)

class MAVLink_cmd_goto_state_message(MAVLink_message):
        '''

        '''
        id = MAVLINK_MSG_ID_CMD_GOTO_STATE
        name = 'CMD_GOTO_STATE'
        fieldnames = ['state']
        ordered_fieldnames = ['state']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"state": "ENGINE_COMPUTER_STATE"}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 230
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, state):
                MAVLink_message.__init__(self, MAVLink_cmd_goto_state_message.id, MAVLink_cmd_goto_state_message.name)
                self._fieldnames = MAVLink_cmd_goto_state_message.fieldnames
                self._instance_field = MAVLink_cmd_goto_state_message.instance_field
                self._instance_offset = MAVLink_cmd_goto_state_message.instance_offset
                self.state = state

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 230, struct.pack('<B', self.state), force_mavlink1=force_mavlink1)

class MAVLink_cmd_proceed_message(MAVLink_message):
        '''

        '''
        id = MAVLINK_MSG_ID_CMD_PROCEED
        name = 'CMD_PROCEED'
        fieldnames = []
        ordered_fieldnames = []
        fieldtypes = []
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<'
        native_format = bytearray('<', 'ascii')
        orders = []
        lengths = []
        array_lengths = []
        crc_extra = 28
        unpacker = struct.Struct('<')
        instance_field = None
        instance_offset = -1

        def __init__(self):
                MAVLink_message.__init__(self, MAVLink_cmd_proceed_message.id, MAVLink_cmd_proceed_message.name)
                self._fieldnames = MAVLink_cmd_proceed_message.fieldnames
                self._instance_field = MAVLink_cmd_proceed_message.instance_field
                self._instance_offset = MAVLink_cmd_proceed_message.instance_offset

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 28, struct.pack('<'), force_mavlink1=force_mavlink1)

class MAVLink_cmd_set_valve_message(MAVLink_message):
        '''

        '''
        id = MAVLINK_MSG_ID_CMD_SET_VALVE
        name = 'CMD_SET_VALVE'
        fieldnames = ['valve', 'valve_mode', 'desired_position']
        ordered_fieldnames = ['valve', 'valve_mode', 'desired_position']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"valve": "VALVE", "valve_mode": "VALVE_MODE"}
        fieldunits_by_name = {}
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 32
        unpacker = struct.Struct('<BBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, valve, valve_mode, desired_position):
                MAVLink_message.__init__(self, MAVLink_cmd_set_valve_message.id, MAVLink_cmd_set_valve_message.name)
                self._fieldnames = MAVLink_cmd_set_valve_message.fieldnames
                self._instance_field = MAVLink_cmd_set_valve_message.instance_field
                self._instance_offset = MAVLink_cmd_set_valve_message.instance_offset
                self.valve = valve
                self.valve_mode = valve_mode
                self.desired_position = desired_position

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 32, struct.pack('<BBB', self.valve, self.valve_mode, self.desired_position), force_mavlink1=force_mavlink1)

class MAVLink_cmd_set_power_source_message(MAVLink_message):
        '''

        '''
        id = MAVLINK_MSG_ID_CMD_SET_POWER_SOURCE
        name = 'CMD_SET_POWER_SOURCE'
        fieldnames = ['power_source']
        ordered_fieldnames = ['power_source']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"power_source": "POWER_SOURCE"}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 57
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, power_source):
                MAVLink_message.__init__(self, MAVLink_cmd_set_power_source_message.id, MAVLink_cmd_set_power_source_message.name)
                self._fieldnames = MAVLink_cmd_set_power_source_message.fieldnames
                self._instance_field = MAVLink_cmd_set_power_source_message.instance_field
                self._instance_offset = MAVLink_cmd_set_power_source_message.instance_offset
                self.power_source = power_source

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 57, struct.pack('<B', self.power_source), force_mavlink1=force_mavlink1)

class MAVLink_set_arm_state_message(MAVLink_message):
        '''

        '''
        id = MAVLINK_MSG_ID_SET_ARM_STATE
        name = 'SET_ARM_STATE'
        fieldnames = ['arm_state']
        ordered_fieldnames = ['arm_state']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"arm_state": "ARM_STATE"}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 252
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, arm_state):
                MAVLink_message.__init__(self, MAVLink_set_arm_state_message.id, MAVLink_set_arm_state_message.name)
                self._fieldnames = MAVLink_set_arm_state_message.fieldnames
                self._instance_field = MAVLink_set_arm_state_message.instance_field
                self._instance_offset = MAVLink_set_arm_state_message.instance_offset
                self.arm_state = arm_state

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 252, struct.pack('<B', self.arm_state), force_mavlink1=force_mavlink1)


mavlink_map = {
        MAVLINK_MSG_ID_HEARTBEAT : MAVLink_heartbeat_message,
        MAVLINK_MSG_ID_PREP_CMD : MAVLink_prep_cmd_message,
        MAVLINK_MSG_ID_ACK_CMD : MAVLink_ack_cmd_message,
        MAVLINK_MSG_ID_CMD_REQUEST_MESSAGE : MAVLink_cmd_request_message_message,
        MAVLINK_MSG_ID_CMD_SET_MESSAGE_INTERVAL : MAVLink_cmd_set_message_interval_message,
        MAVLINK_MSG_ID_ENGINE_SENSORS : MAVLink_engine_sensors_message,
        MAVLINK_MSG_ID_TANK_SENSORS : MAVLink_tank_sensors_message,
        MAVLINK_MSG_ID_POWER_SENSOR : MAVLink_power_sensor_message,
        MAVLINK_MSG_ID_ENGINE_COMPUTER_STATUS : MAVLink_engine_computer_status_message,
        MAVLINK_MSG_ID_CMD_ABORT : MAVLink_cmd_abort_message,
        MAVLINK_MSG_ID_CMD_GOTO_STATE : MAVLink_cmd_goto_state_message,
        MAVLINK_MSG_ID_CMD_PROCEED : MAVLink_cmd_proceed_message,
        MAVLINK_MSG_ID_CMD_SET_VALVE : MAVLink_cmd_set_valve_message,
        MAVLINK_MSG_ID_CMD_SET_POWER_SOURCE : MAVLink_cmd_set_power_source_message,
        MAVLINK_MSG_ID_SET_ARM_STATE : MAVLink_set_arm_state_message,
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data
                self._instance_field = None

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLinkSigning(object):
    '''MAVLink signing state class'''
    def __init__(self):
        self.secret_key = None
        self.timestamp = 0
        self.link_id = 0
        self.sign_outgoing = False
        self.allow_unsigned_callback = None
        self.stream_timestamps = {}
        self.sig_count = 0
        self.badsig_count = 0
        self.goodsig_count = 0
        self.unsigned_count = 0
        self.reject_count = 0

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0, use_native=False):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = bytearray()
                self.buf_index = 0
                self.expected_length = HEADER_LEN_V1+2
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 254
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()
                self.signing = MAVLinkSigning()
                if native_supported and (use_native or native_testing or native_force):
                    print("NOTE: mavnative is currently beta-test code")
                    self.native = mavnative.NativeConnection(MAVLink_message, mavlink_map)
                else:
                    self.native = None
                if native_testing:
                    self.test_buf = bytearray()
                self.mav20_unpacker = struct.Struct('<cBBBBBBHB')
                self.mav10_unpacker = struct.Struct('<cBBBBB')
                self.mav20_h3_unpacker = struct.Struct('BBB')
                self.mav_csum_unpacker = struct.Struct('<H')
                self.mav_sign_unpacker = struct.Struct('<IH')

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg, force_mavlink1=False):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def buf_len(self):
            return len(self.buf) - self.buf_index

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            if self.native:
                ret = self.native.expected_length - self.buf_len()
            else:
                ret = self.expected_length - self.buf_len()

            if ret <= 0:
                return 1
            return ret

        def __parse_char_native(self, c):
            '''this method exists only to see in profiling results'''
            m = self.native.parse_chars(c)
            return m

        def __callbacks(self, msg):
            '''this method exists only to make profiling results easier to read'''
            if self.callback:
                self.callback(msg, *self.callback_args, **self.callback_kwargs)

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            self.buf.extend(c)

            self.total_bytes_received += len(c)

            if self.native:
                if native_testing:
                    self.test_buf.extend(c)
                    m = self.__parse_char_native(self.test_buf)
                    m2 = self.__parse_char_legacy()
                    if m2 != m:
                        print("Native: %s\nLegacy: %s\n" % (m, m2))
                        raise Exception('Native vs. Legacy mismatch')
                else:
                    m = self.__parse_char_native(self.buf)
            else:
                m = self.__parse_char_legacy()

            if m is not None:
                self.total_packets_received += 1
                self.__callbacks(m)
            else:
                # XXX The idea here is if we've read something and there's nothing left in
                # the buffer, reset it to 0 which frees the memory
                if self.buf_len() == 0 and self.buf_index != 0:
                    self.buf = bytearray()
                    self.buf_index = 0

            return m

        def __parse_char_legacy(self):
            '''input some data bytes, possibly returning a new message (uses no native code)'''
            header_len = HEADER_LEN_V1
            if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
                header_len = HEADER_LEN_V2

            if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
                magic = self.buf[self.buf_index]
                self.buf_index += 1
                if self.robust_parsing:
                    m = MAVLink_bad_data(bytearray([magic]), 'Bad prefix')
                    self.expected_length = header_len+2
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if self.buf_len() >= 3:
                sbuf = self.buf[self.buf_index:3+self.buf_index]
                if sys.version_info.major < 3:
                    sbuf = str(sbuf)
                (magic, self.expected_length, incompat_flags) = self.mav20_h3_unpacker.unpack(sbuf)
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                        self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
                self.expected_length += header_len + 2
            if self.expected_length >= (header_len+2) and self.buf_len() >= self.expected_length:
                mbuf = array.array('B', self.buf[self.buf_index:self.buf_index+self.expected_length])
                self.buf_index += self.expected_length
                self.expected_length = header_len+2
                if self.robust_parsing:
                    try:
                        if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                            raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                        m = self.decode(mbuf)
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def check_signature(self, msgbuf, srcSystem, srcComponent):
            '''check signature on incoming message'''
            if isinstance(msgbuf, array.array):
                msgbuf = msgbuf.tostring()
            timestamp_buf = msgbuf[-12:-6]
            link_id = msgbuf[-13]
            (tlow, thigh) = self.mav_sign_unpacker.unpack(timestamp_buf)
            timestamp = tlow + (thigh<<32)

            # see if the timestamp is acceptable
            stream_key = (link_id,srcSystem,srcComponent)
            if stream_key in self.signing.stream_timestamps:
                if timestamp <= self.signing.stream_timestamps[stream_key]:
                    # reject old timestamp
                    # print('old timestamp')
                    return False
            else:
                # a new stream has appeared. Accept the timestamp if it is at most
                # one minute behind our current timestamp
                if timestamp + 6000*1000 < self.signing.timestamp:
                    # print('bad new stream ', timestamp/(100.0*1000*60*60*24*365), self.signing.timestamp/(100.0*1000*60*60*24*365))
                    return False
                self.signing.stream_timestamps[stream_key] = timestamp
                # print('new stream')

            h = hashlib.new('sha256')
            h.update(self.signing.secret_key)
            h.update(msgbuf[:-6])
            if str(type(msgbuf)) == "<class 'bytes'>" or str(type(msgbuf)) == "<class 'bytearray'>":
                # Python 3
                sig1 = h.digest()[:6]
                sig2 = msgbuf[-6:]
            else:
                sig1 = str(h.digest())[:6]
                sig2 = str(msgbuf)[-6:]
            if sig1 != sig2:
                # print('sig mismatch')
                return False

            # the timestamp we next send with is the max of the received timestamp and
            # our current timestamp
            self.signing.timestamp = max(self.signing.timestamp, timestamp)
            return True

        # swiped from DFReader.py
        def to_string(self, s):
            '''desperate attempt to convert a string regardless of what garbage we get'''
            try:
                return s.decode("utf-8")
            except Exception as e:
                pass
            try:
                s2 = s.encode('utf-8', 'ignore')
                x = u"%s" % s2
                return s2
            except Exception:
                pass
            # so its a nasty one. Let's grab as many characters as we can
            r = ''
            while s != '':
                try:
                    r2 = r + s[0]
                    s = s[1:]
                    r2 = r2.encode('ascii', 'ignore')
                    x = u"%s" % r2
                    r = r2
                except Exception:
                    break
            return r + '_XXX'

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                if msgbuf[0] != PROTOCOL_MARKER_V1:
                    headerlen = 10
                    try:
                        magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = self.mav20_unpacker.unpack(msgbuf[:headerlen])
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    msgId = msgIdlow | (msgIdhigh<<16)
                    mapkey = msgId
                else:
                    headerlen = 6
                    try:
                        magic, mlen, seq, srcSystem, srcComponent, msgId = self.mav10_unpacker.unpack(msgbuf[:headerlen])
                        incompat_flags = 0
                        compat_flags = 0
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    mapkey = msgId
                if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
                    signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
                else:
                    signature_len = 0

                if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-(headerlen+2+signature_len):
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u' % (len(msgbuf)-(headerlen+2+signature_len), mlen, msgId, headerlen))

                if not mapkey in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %s' % str(mapkey))

                # decode the payload
                type = mavlink_map[mapkey]
                fmt = type.format
                order_map = type.orders
                len_map = type.lengths
                crc_extra = type.crc_extra

                # decode the checksum
                try:
                    crc, = self.mav_csum_unpacker.unpack(msgbuf[-(2+signature_len):][:2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crcbuf = msgbuf[1:-(2+signature_len)]
                if True: # using CRC extra
                    crcbuf.append(crc_extra)
                crc2 = x25crc(crcbuf)
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                sig_ok = False
                if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                    self.signing.sig_count += 1
                if self.signing.secret_key is not None:
                    accept_signature = False
                    if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                        sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                        accept_signature = sig_ok
                        if sig_ok:
                            self.signing.goodsig_count += 1
                        else:
                            self.signing.badsig_count += 1
                        if not accept_signature and self.signing.allow_unsigned_callback is not None:
                            accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                            if accept_signature:
                                self.signing.unsigned_count += 1
                            else:
                                self.signing.reject_count += 1
                    elif self.signing.allow_unsigned_callback is not None:
                        accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                        if accept_signature:
                            self.signing.unsigned_count += 1
                        else:
                            self.signing.reject_count += 1
                    if not accept_signature:
                        raise MAVError('Invalid signature')

                csize = type.unpacker.size
                mbuf = msgbuf[headerlen:-(2+signature_len)]
                if len(mbuf) < csize:
                    # zero pad to give right size
                    mbuf.extend([0]*(csize - len(mbuf)))
                if len(mbuf) < csize:
                    raise MAVError('Bad message of type %s length %u needs %s' % (
                        type, len(mbuf), csize))
                mbuf = mbuf[:csize]
                try:
                    t = type.unpacker.unpack(mbuf)
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(mbuf), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if type.fieldtypes[i] == 'char':
                        if sys.version_info.major >= 3:
                            tlist[i] = self.to_string(tlist[i])
                        tlist[i] = str(MAVString(tlist[i]))
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._signed = sig_ok
                if m._signed:
                    m._link_id = msgbuf[-13]
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-(2+signature_len)]
                m._crc = crc
                m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
                return m
        def heartbeat_encode(self, system_type, component_type):
                '''
                

                system_type               :  (type:uint8_t)
                component_type            :  (type:uint8_t)

                '''
                return MAVLink_heartbeat_message(system_type, component_type)

        def heartbeat_send(self, system_type, component_type, force_mavlink1=False):
                '''
                

                system_type               :  (type:uint8_t)
                component_type            :  (type:uint8_t)

                '''
                return self.send(self.heartbeat_encode(system_type, component_type), force_mavlink1=force_mavlink1)

        def prep_cmd_encode(self, target_system, target_component, message_id):
                '''
                Send before an important command which needs acknowledgement. Only
                relevant systems/components should take action.
                Commands are ignored if this is not received.

                target_system             :  (type:uint8_t)
                target_component          : 0 for all components in target_system (type:uint8_t)
                message_id                :  (type:uint8_t)

                '''
                return MAVLink_prep_cmd_message(target_system, target_component, message_id)

        def prep_cmd_send(self, target_system, target_component, message_id, force_mavlink1=False):
                '''
                Send before an important command which needs acknowledgement. Only
                relevant systems/components should take action.
                Commands are ignored if this is not received.

                target_system             :  (type:uint8_t)
                target_component          : 0 for all components in target_system (type:uint8_t)
                message_id                :  (type:uint8_t)

                '''
                return self.send(self.prep_cmd_encode(target_system, target_component, message_id), force_mavlink1=force_mavlink1)

        def ack_cmd_encode(self, message_id, result):
                '''
                Acknowledges that a command was received and successfully executed.

                message_id                :  (type:uint8_t)
                result                    : Allows indicating whether command succesfully completed (type:uint8_t, values:ACK_RESULT)

                '''
                return MAVLink_ack_cmd_message(message_id, result)

        def ack_cmd_send(self, message_id, result, force_mavlink1=False):
                '''
                Acknowledges that a command was received and successfully executed.

                message_id                :  (type:uint8_t)
                result                    : Allows indicating whether command succesfully completed (type:uint8_t, values:ACK_RESULT)

                '''
                return self.send(self.ack_cmd_encode(message_id, result), force_mavlink1=force_mavlink1)

        def cmd_request_message_encode(self, message_id):
                '''
                Asks for one-time transmission of a certain message

                message_id                :  (type:uint8_t)

                '''
                return MAVLink_cmd_request_message_message(message_id)

        def cmd_request_message_send(self, message_id, force_mavlink1=False):
                '''
                Asks for one-time transmission of a certain message

                message_id                :  (type:uint8_t)

                '''
                return self.send(self.cmd_request_message_encode(message_id), force_mavlink1=force_mavlink1)

        def cmd_set_message_interval_encode(self, message_id, interval):
                '''
                Asks for repeat transmission of a certain message

                message_id                :  (type:uint8_t)
                interval                  : 0 to disable [ms] (type:uint16_t)

                '''
                return MAVLink_cmd_set_message_interval_message(message_id, interval)

        def cmd_set_message_interval_send(self, message_id, interval, force_mavlink1=False):
                '''
                Asks for repeat transmission of a certain message

                message_id                :  (type:uint8_t)
                interval                  : 0 to disable [ms] (type:uint16_t)

                '''
                return self.send(self.cmd_set_message_interval_encode(message_id, interval), force_mavlink1=force_mavlink1)

        def engine_sensors_encode(self, fuel_main_valve_mode, fuel_main_valve_position, fuel_main_valve_desired_position, fuel_main_valve_motor_power, ox_main_valve_mode, ox_main_valve_position, ox_main_valve_desired_position, ox_main_valve_motor_power, fuel_injector_pressure, fuel_injector_pressure_status, ox_injector_pressure, ox_injector_pressure_status, thrust, ignitor_status):
                '''
                All engine sensor info

                fuel_main_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                fuel_main_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                fuel_main_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                fuel_main_valve_motor_power        : Motor power level (type:uint8_t)
                ox_main_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                ox_main_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                ox_main_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                ox_main_valve_motor_power        : Motor power level (type:uint8_t)
                fuel_injector_pressure        : Pressure sensor reading at fuel injector [bar] (type:float)
                fuel_injector_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                ox_injector_pressure        : Pressure sensor reading at ox injector [bar] (type:float)
                ox_injector_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                thrust                    : Load cell reading [N] (type:float)
                ignitor_status            : Ignitor continuity and firing state (type:uint8_t, values:IGNITOR_STATUS)

                '''
                return MAVLink_engine_sensors_message(fuel_main_valve_mode, fuel_main_valve_position, fuel_main_valve_desired_position, fuel_main_valve_motor_power, ox_main_valve_mode, ox_main_valve_position, ox_main_valve_desired_position, ox_main_valve_motor_power, fuel_injector_pressure, fuel_injector_pressure_status, ox_injector_pressure, ox_injector_pressure_status, thrust, ignitor_status)

        def engine_sensors_send(self, fuel_main_valve_mode, fuel_main_valve_position, fuel_main_valve_desired_position, fuel_main_valve_motor_power, ox_main_valve_mode, ox_main_valve_position, ox_main_valve_desired_position, ox_main_valve_motor_power, fuel_injector_pressure, fuel_injector_pressure_status, ox_injector_pressure, ox_injector_pressure_status, thrust, ignitor_status, force_mavlink1=False):
                '''
                All engine sensor info

                fuel_main_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                fuel_main_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                fuel_main_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                fuel_main_valve_motor_power        : Motor power level (type:uint8_t)
                ox_main_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                ox_main_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                ox_main_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                ox_main_valve_motor_power        : Motor power level (type:uint8_t)
                fuel_injector_pressure        : Pressure sensor reading at fuel injector [bar] (type:float)
                fuel_injector_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                ox_injector_pressure        : Pressure sensor reading at ox injector [bar] (type:float)
                ox_injector_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                thrust                    : Load cell reading [N] (type:float)
                ignitor_status            : Ignitor continuity and firing state (type:uint8_t, values:IGNITOR_STATUS)

                '''
                return self.send(self.engine_sensors_encode(fuel_main_valve_mode, fuel_main_valve_position, fuel_main_valve_desired_position, fuel_main_valve_motor_power, ox_main_valve_mode, ox_main_valve_position, ox_main_valve_desired_position, ox_main_valve_motor_power, fuel_injector_pressure, fuel_injector_pressure_status, ox_injector_pressure, ox_injector_pressure_status, thrust, ignitor_status), force_mavlink1=force_mavlink1)

        def tank_sensors_encode(self, fuel_vent_valve_mode, fuel_vent_valve_position, fuel_vent_valve_desired_position, fuel_vent_valve_motor_power, ox_vent_valve_mode, ox_vent_valve_position, ox_vent_valve_desired_position, ox_vent_valve_motor_power, fuel_tank_pressure, fuel_tank_pressure_status, ox_tank_pressure, ox_tank_pressure_status, fuel_tank_fill_level, ox_tank_fill_level, fill_lines_detected):
                '''
                All tank sensor info

                fuel_vent_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                fuel_vent_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                fuel_vent_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                fuel_vent_valve_motor_power        : Motor power level (type:uint8_t)
                ox_vent_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                ox_vent_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                ox_vent_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                ox_vent_valve_motor_power        : Motor power level (type:uint8_t)
                fuel_tank_pressure        : Pressure sensor reading at fuel injector [bar] (type:float)
                fuel_tank_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                ox_tank_pressure          : Pressure sensor reading at ox injector [bar] (type:float)
                ox_tank_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                fuel_tank_fill_level        : Fuel tank fill level sensor. gives percentage of liquid in tank [%] (type:uint8_t)
                ox_tank_fill_level        : Ox tank fill level sensor [%] (type:uint8_t)
                fill_lines_detected        :  (type:uint8_t, values:TANK_FLAGS)

                '''
                return MAVLink_tank_sensors_message(fuel_vent_valve_mode, fuel_vent_valve_position, fuel_vent_valve_desired_position, fuel_vent_valve_motor_power, ox_vent_valve_mode, ox_vent_valve_position, ox_vent_valve_desired_position, ox_vent_valve_motor_power, fuel_tank_pressure, fuel_tank_pressure_status, ox_tank_pressure, ox_tank_pressure_status, fuel_tank_fill_level, ox_tank_fill_level, fill_lines_detected)

        def tank_sensors_send(self, fuel_vent_valve_mode, fuel_vent_valve_position, fuel_vent_valve_desired_position, fuel_vent_valve_motor_power, ox_vent_valve_mode, ox_vent_valve_position, ox_vent_valve_desired_position, ox_vent_valve_motor_power, fuel_tank_pressure, fuel_tank_pressure_status, ox_tank_pressure, ox_tank_pressure_status, fuel_tank_fill_level, ox_tank_fill_level, fill_lines_detected, force_mavlink1=False):
                '''
                All tank sensor info

                fuel_vent_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                fuel_vent_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                fuel_vent_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                fuel_vent_valve_motor_power        : Motor power level (type:uint8_t)
                ox_vent_valve_mode        : current valve control mode (type:uint8_t, values:VALVE_MODE)
                ox_vent_valve_position        : Position valve is currently at. NaN if valve is not yet homed. [%open] (type:uint8_t)
                ox_vent_valve_desired_position        : Position valve is supposed to be moving toward. NaN if position was never set [%open] (type:uint8_t)
                ox_vent_valve_motor_power        : Motor power level (type:uint8_t)
                fuel_tank_pressure        : Pressure sensor reading at fuel injector [bar] (type:float)
                fuel_tank_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                ox_tank_pressure          : Pressure sensor reading at ox injector [bar] (type:float)
                ox_tank_pressure_status        :  (type:uint8_t, values:PRESSURE_STATUS)
                fuel_tank_fill_level        : Fuel tank fill level sensor. gives percentage of liquid in tank [%] (type:uint8_t)
                ox_tank_fill_level        : Ox tank fill level sensor [%] (type:uint8_t)
                fill_lines_detected        :  (type:uint8_t, values:TANK_FLAGS)

                '''
                return self.send(self.tank_sensors_encode(fuel_vent_valve_mode, fuel_vent_valve_position, fuel_vent_valve_desired_position, fuel_vent_valve_motor_power, ox_vent_valve_mode, ox_vent_valve_position, ox_vent_valve_desired_position, ox_vent_valve_motor_power, fuel_tank_pressure, fuel_tank_pressure_status, ox_tank_pressure, ox_tank_pressure_status, fuel_tank_fill_level, ox_tank_fill_level, fill_lines_detected), force_mavlink1=force_mavlink1)

        def power_sensor_encode(self, power_source, battery_voltage, battery_status):
                '''
                Info about power supply

                power_source              : Battery or external supply (type:uint8_t, values:POWER_SOURCE)
                battery_voltage           : Battery voltage [mV] (type:uint16_t)
                battery_status            :  (type:uint8_t, values:BATTERY_STATUS)

                '''
                return MAVLink_power_sensor_message(power_source, battery_voltage, battery_status)

        def power_sensor_send(self, power_source, battery_voltage, battery_status, force_mavlink1=False):
                '''
                Info about power supply

                power_source              : Battery or external supply (type:uint8_t, values:POWER_SOURCE)
                battery_voltage           : Battery voltage [mV] (type:uint16_t)
                battery_status            :  (type:uint8_t, values:BATTERY_STATUS)

                '''
                return self.send(self.power_sensor_encode(power_source, battery_voltage, battery_status), force_mavlink1=force_mavlink1)

        def engine_computer_status_encode(self, state, state_proceed, state_abort, abort_flags, arm_state, cpu_load):
                '''
                Info about state machine, arming, abort-worthy issues

                state                     :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)
                state_proceed             :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)
                state_abort               :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)
                abort_flags               :  (type:uint16_t, values:ABORT_CONDITION_FLAGS)
                arm_state                 :  (type:uint8_t, values:ARM_STATE)
                cpu_load                  :  [%] (type:uint8_t)

                '''
                return MAVLink_engine_computer_status_message(state, state_proceed, state_abort, abort_flags, arm_state, cpu_load)

        def engine_computer_status_send(self, state, state_proceed, state_abort, abort_flags, arm_state, cpu_load, force_mavlink1=False):
                '''
                Info about state machine, arming, abort-worthy issues

                state                     :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)
                state_proceed             :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)
                state_abort               :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)
                abort_flags               :  (type:uint16_t, values:ABORT_CONDITION_FLAGS)
                arm_state                 :  (type:uint8_t, values:ARM_STATE)
                cpu_load                  :  [%] (type:uint8_t)

                '''
                return self.send(self.engine_computer_status_encode(state, state_proceed, state_abort, abort_flags, arm_state, cpu_load), force_mavlink1=force_mavlink1)

        def cmd_abort_encode(self, hard):
                '''
                

                hard                      : 0 for normal abort. 1 for hard abort. (type:uint8_t)

                '''
                return MAVLink_cmd_abort_message(hard)

        def cmd_abort_send(self, hard, force_mavlink1=False):
                '''
                

                hard                      : 0 for normal abort. 1 for hard abort. (type:uint8_t)

                '''
                return self.send(self.cmd_abort_encode(hard), force_mavlink1=force_mavlink1)

        def cmd_goto_state_encode(self, state):
                '''
                

                state                     :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)

                '''
                return MAVLink_cmd_goto_state_message(state)

        def cmd_goto_state_send(self, state, force_mavlink1=False):
                '''
                

                state                     :  (type:uint8_t, values:ENGINE_COMPUTER_STATE)

                '''
                return self.send(self.cmd_goto_state_encode(state), force_mavlink1=force_mavlink1)

        def cmd_proceed_encode(self):
                '''
                


                '''
                return MAVLink_cmd_proceed_message()

        def cmd_proceed_send(self, force_mavlink1=False):
                '''
                


                '''
                return self.send(self.cmd_proceed_encode(), force_mavlink1=force_mavlink1)

        def cmd_set_valve_encode(self, valve, valve_mode, desired_position):
                '''
                

                valve                     :  (type:uint8_t, values:VALVE)
                valve_mode                :  (type:uint8_t, values:VALVE_MODE)
                desired_position          : don't save this value unless in position control mode (type:uint8_t)

                '''
                return MAVLink_cmd_set_valve_message(valve, valve_mode, desired_position)

        def cmd_set_valve_send(self, valve, valve_mode, desired_position, force_mavlink1=False):
                '''
                

                valve                     :  (type:uint8_t, values:VALVE)
                valve_mode                :  (type:uint8_t, values:VALVE_MODE)
                desired_position          : don't save this value unless in position control mode (type:uint8_t)

                '''
                return self.send(self.cmd_set_valve_encode(valve, valve_mode, desired_position), force_mavlink1=force_mavlink1)

        def cmd_set_power_source_encode(self, power_source):
                '''
                

                power_source              :  (type:uint8_t, values:POWER_SOURCE)

                '''
                return MAVLink_cmd_set_power_source_message(power_source)

        def cmd_set_power_source_send(self, power_source, force_mavlink1=False):
                '''
                

                power_source              :  (type:uint8_t, values:POWER_SOURCE)

                '''
                return self.send(self.cmd_set_power_source_encode(power_source), force_mavlink1=force_mavlink1)

        def set_arm_state_encode(self, arm_state):
                '''
                

                arm_state                 :  (type:uint8_t, values:ARM_STATE)

                '''
                return MAVLink_set_arm_state_message(arm_state)

        def set_arm_state_send(self, arm_state, force_mavlink1=False):
                '''
                

                arm_state                 :  (type:uint8_t, values:ARM_STATE)

                '''
                return self.send(self.set_arm_state_encode(arm_state), force_mavlink1=force_mavlink1)

